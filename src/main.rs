use regex::Regex;
use std::fs::{self, File};
use std::io::{self, Write};
use chrono::Local;



fn main() -> io::Result<()> {
    let column_res = String::from(r#"
        pub\s+(\w+)\s*:\s*(\w+)\s*,\s*
    "#).replace(" ", "").replace("\n", "");

    /* Regexp:
        (?:\s*\/\/.*\n)*?       # Ignore single-line comments
        (?:\s*\/\*.*?\*\/\s*)?  # Ignore multi-line comments
     */
    let table_res = [
        r#"
        #\[table_name\s+=\s+"(\w+)"\]\s*
        pub\s+struct\s+(\w+(?:\s*<[\w'&\s]+>)?)\s*\{
            (\s*
                (
                    (?:\s*\/\/.*\n)*?
                    (?:\s*\/\*.*?\*\/\s*)?
        "#,
        column_res.as_str(),
        r#"
                )+
            )
        \}\s*
    "#
    ].join("\n").replace(" ", "").replace("\n", "");
    
    let table_re =  Regex::new(table_res.as_str()).unwrap();
    let column_re = Regex::new(column_res.as_str()).unwrap();

    println!("Reading models.rs file...");
    let models_content = match fs::read_to_string("../webserver/src/models.rs") {
        Ok(content) => content,
        Err(e) => {
            println!("FATAL: Failed to open models.rs file: {}", e);

            return Err(e);
        }
    };

    println!("Creating schema.rs file...");
    let mut schema_rs = match File::create("../webserver/src/schema.rs") { 
        Ok(file) => file,
        Err(e) => {
            println!("FATAL: Failed to create schema.rs file: {}", e);

            return Err(e);
        }
    };
    writeln!(schema_rs, "// WARNING: AUTOGENERATED BY model2chema")?;
    writeln!(schema_rs, "#![allow(non_local_definitions)]")?;

    println!("Iterate over each table definition..");
    let mut number_of_tables = 0;
    for table_match in table_re.captures_iter(&models_content) {
        let first = &table_match[0];
        let table_name = &table_match[1];
        let primary_key = "id";
        let struct_name = &table_match[2];
        let columns_definition = &table_match[3];
        
        // Start the table! statement
        println!("Creating table: '{}' with expected primary_key '{}' for struct name '{}'", table_name, primary_key, struct_name);
        writeln!(schema_rs, "table! {}", '{')?;
        writeln!(schema_rs, "    {} ({}) {}", table_name, primary_key, '{')?;

        println!("  Iterate over each column definition..");
        println!("     first: \n'\n{}'", first);
        println!("     columns_definition: \n     ==============={}     ===============", columns_definition.replace("    ", "        "));
        let mut column_iter = column_re.captures_iter(columns_definition);
        let mut first_column_ok = false;
        let mut number_of_columns = 0;
        if let Some(first_column) = column_iter.next() {
            if first_column.len() < 2   {
                panic!("FATAL: Column definition first_column not found for table: '{}'", table_name);
            } else {
                let first_column_name = first_column[1].to_string();
                let first_column_type = first_column[2].to_string();
                if first_column_name == primary_key && first_column_type == "Uuid" {
                    println!("     first_column: '{}' : '{}'", first_column_name, first_column_type);
                    number_of_columns += 1;
                    first_column_ok = true;
                } else {
                    println!("WARNING: First column '{}' with type '{}' is not  primary key: '{}'", first_column_name, first_column_type, primary_key);
                }
                writeln!(schema_rs, "        {} -> {},", first_column_name, map_column_type(&first_column_type).to_string())?;
            }
        } else {
            panic!("FATAL: Column definition first_column not found for table: '{}'", table_name);
        }
        
        // Add the remaining columns
        for column_match in column_iter {
            if column_match.len() < 3 {
                panic!("Column definition column_match not found for table: {}", table_name);
            } else {
                // I cant get the matching of the optimal column to work!
                let column_name = column_match[1].trim().to_string();
                let column_type = column_match[2].trim().to_string();
                if column_name.ends_with("_opt") {
                    println!("OPTIONAL")
                }
                println!("     column_match: '{}' => '{}' type: '{}'", column_match[0].trim().to_string(), column_name, column_type);
                writeln!(schema_rs, "        {} -> {},", column_name, map_column_type(&column_type).to_string())?;
                number_of_columns += 1; 
            }

        }
        writeln!(schema_rs, "    {}", '}')?;

        if number_of_columns == 0 {
            panic!("FATAL: No columns found in models.rs file for table {}.", table_name);
        } else if first_column_ok  {
            println!("Table '{}' generated successfully with {} columns.", table_name, number_of_columns);
        } else {
            println!("WARNING: table '{}': generated without valid primary column in models.rs file.", table_name);
        }

        writeln!(schema_rs, "{}", '}')?;
        writeln!(schema_rs, "")?;
        number_of_tables += 1; 
    }

    if number_of_tables == 0 {
        panic!("ERROR: No table found in models.rs file.");
    } else {
        println!("DONE: schema.rs generated successfully with {} tables.", number_of_tables);
    }

    match schema_rs.flush() {
        Ok(_) => return Ok(()),
        Err(e) => {
            println!("FATAL: schema.rs: {}", e);
            return Err(e);
        }
    }
}

// Function to map rust types to diesel types
fn map_column_type(rust_type: &str) -> &str {
    match rust_type {
        "Uuid" => "Uuid",
        "String" => "Varchar",
        "i32" => "Int4",
        "i16" => "Int2",
        "i8" => "Int8",
//        "Text" => "Text",
        "bool" => "Bool",
        "Bool" => "Bool",
        "f32" => "Float4",
        "f64" => "Float8",
        "Instant" => "Timestamp",
        "NaiveDate" => "Date",
        "NaiveTime" => "Time",
        "TimeDelta" => "Interval",
        "DateTime" => "DateTime",
        //"Bytea" => "Bytea",
        "Vec<Text>" => "Array<Text>",
        "Vec<Uuid>" => "Array<Uuid>",
        "Vec<Int8>" => "Array<Int8>",
        "Vec<Int4>" => "Array<Int4>",
        "Vec<Int2>" => "Array<Int2>",
        "Vec<bool>" => "Array<Bool>",
        "Vec<Bool>" => "Array<Bool>",
        "Value" => "Jsonb", // serde_json::Value
        _ => "Int4", // Default to Int4 for unknown types
    }
}

